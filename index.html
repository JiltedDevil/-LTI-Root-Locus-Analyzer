<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>LTI Root Locus Analyzer (Mobile Touch)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'system-ui', 'sans-serif'],
              mono: ['JetBrains Mono', 'monospace'],
            },
            colors: {
              primary: { 500: '#6366f1', 600: '#4f46e5' }
            }
          }
        }
      }
    </script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');
      body { font-family: 'Inter', sans-serif; background-color: #f9fafb; color: #1f2937; overscroll-behavior: none; }
      .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
      .custom-scrollbar::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 10px; }
      input[type=range] { -webkit-appearance: none; background: transparent; }
      input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 18px; width: 18px; border-radius: 50%; background: #4f46e5; cursor: pointer; margin-top: -7px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border: 2px solid #fff; }
      input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #e5e7eb; border-radius: 2px; }
      .initial-loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #ffffff; z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.5s ease-out; }
      .spinner { width: 40px; height: 40px; border: 3px solid #e0e7ff; border-top-color: #4f46e5; border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 1rem; }
      @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="root">
        <div class="initial-loader" id="loader">
            <div class="spinner"></div>
            <div class="font-medium text-sm tracking-wide text-gray-500">Initializing Engine...</div>
        </div>
    </div>

    <script type="text/babel">
        // --- WORKER SCRIPT (Math Logic) ---
        const workerScript = `
            const addComplex = (a, b) => ({ re: a.re + b.re, im: a.im + b.im });
            const subComplex = (a, b) => ({ re: a.re - b.re, im: a.im - b.im });
            const mulComplex = (a, b) => ({ re: a.re * b.re - a.im * b.im, im: a.re * b.im + a.im * b.re, });
            const divComplex = (a, b) => { const denom = b.re * b.re + b.im * b.im; return { re: (a.re * b.re + a.im * b.im) / denom, im: (a.im * b.re - a.re * b.im) / denom, }; };
            const absComplex = (a) => Math.sqrt(a.re * a.re + a.im * a.im);
            const evalPoly = (coeffs, s) => { let result = { re: 0, im: 0 }; for (let i = 0; i < coeffs.length; i++) { result = mulComplex(result, s); result = addComplex(result, { re: coeffs[i], im: 0 }); } return result; };
            const polyDerivative = (coeffs) => { if (coeffs.length <= 1) return []; const deriv = []; const n = coeffs.length - 1; for (let i = 0; i < n; i++) deriv.push(coeffs[i] * (n - i)); return deriv; };
            const polyMul = (p1, p2) => { const n = p1.length - 1; const m = p2.length - 1; const result = new Array(n + m + 1).fill(0); for (let i = 0; i <= n; i++) for (let j = 0; j <= m; j++) result[i + j] += p1[i] * p2[j]; return result; };
            const polySub = (p1, p2) => { const n = Math.max(p1.length, p2.length); const result = new Array(n).fill(0); const p1Offset = n - p1.length; const p2Offset = n - p2.length; for(let i=0; i<n; i++) { const v1 = (i >= p1Offset) ? p1[i - p1Offset] : 0; const v2 = (i >= p2Offset) ? p2[i - p2Offset] : 0; result[i] = v1 - v2; } return result; };
            
            const findRoots = (coeffs, maxIter = 50, tolerance = 1e-6) => {
                const n = coeffs.length - 1; if (n < 1) return [];
                let start = 0; while (start < coeffs.length && coeffs[start] === 0) start++;
                const activeCoeffs = coeffs.slice(start); const order = activeCoeffs.length - 1; if (order < 1) return [];
                const a0 = activeCoeffs[0]; const normalizedCoeffs = activeCoeffs.map(c => c / a0);
                let roots = []; const radius = 0.5; 
                for (let i = 0; i < order; i++) { const angle = (2 * Math.PI * i) / order + 0.123; roots.push({ re: radius * Math.cos(angle), im: radius * Math.sin(angle) }); }
                for (let iter = 0; iter < maxIter; iter++) {
                    let maxDiff = 0; const newRoots = [...roots];
                    for (let i = 0; i < order; i++) {
                        const z = roots[i]; const pz = evalPoly(normalizedCoeffs, z);
                        let denominator = { re: 1, im: 0 };
                        for (let j = 0; j < order; j++) if (i !== j) denominator = mulComplex(denominator, subComplex(z, roots[j]));
                        if (Math.abs(denominator.re) < 1e-9 && Math.abs(denominator.im) < 1e-9) denominator = { re: 1e-9, im: 1e-9 };
                        const delta = divComplex(pz, denominator); newRoots[i] = subComplex(z, delta);
                        const diff = absComplex(delta); if (diff > maxDiff) maxDiff = diff;
                    }
                    roots = newRoots; if (maxDiff < tolerance) break;
                }
                roots.sort((a, b) => a.re - b.re || a.im - b.im); return roots;
            };

            const getCharacteristicEq = (num, den, k) => {
                const maxLen = Math.max(num.length, den.length); const paddedNum = new Array(maxLen).fill(0); const paddedDen = new Array(maxLen).fill(0);
                for (let i = 0; i < num.length; i++) paddedNum[maxLen - 1 - i] = num[num.length - 1 - i];
                for (let i = 0; i < den.length; i++) paddedDen[maxLen - 1 - i] = den[den.length - 1 - i];
                const result = new Array(maxLen).fill(0); for (let i = 0; i < maxLen; i++) result[i] = paddedDen[i] + k * paddedNum[i];
                return result;
            };

            const calculateBreakPoints = (num, den) => {
                const numDeriv = polyDerivative(num); const denDeriv = polyDerivative(den);
                const eq = polySub(polyMul(num, denDeriv), polyMul(numDeriv, den));
                if (eq.every(c => Math.abs(c) < 1e-9)) return [];
                const roots = findRoots(eq); const validPoints = [];
                for (const r of roots) {
                    const nVal = evalPoly(num, r); const dVal = evalPoly(den, r);
                    if (absComplex(nVal) < 1e-9) continue;
                    const ratio = divComplex(dVal, nVal); const kVal = { re: -ratio.re, im: -ratio.im };
                    if (Math.abs(kVal.im) < 1e-4 && kVal.re >= -1e-4) validPoints.push({ s: r, k: kVal.re, isBreakaway: true });
                }
                return validPoints;
            };

            const generateRootLocusData = (num, den) => {
                const points = []; const kValues = [];
                for (let i = 0; i <= 40; i++) kValues.push(i * 0.05); for (let i = 1; i <= 80; i++) kValues.push(2 + i * 0.5); for (let i = 1; i <= 50; i++) kValues.push(42 + i * 5); for (let i = 1; i <= 10; i++) kValues.push(300 + i * 200);
                let minX = -5, maxX = 2, minY = -5, maxY = 5;
                for (const k of kValues) {
                    const poly = getCharacteristicEq(num, den, k); const roots = findRoots(poly);
                    points.push({ k, roots });
                    roots.forEach(r => { if(!isNaN(r.re)) { minX = Math.min(minX, r.re); maxX = Math.max(maxX, r.re); minY = Math.min(minY, r.im); maxY = Math.max(maxY, r.im); } });
                }
                const openLoopPoles = findRoots(den); const openLoopZeros = findRoots(num); const breakPoints = calculateBreakPoints(num, den);
                const expandLimits = (arr) => { arr.forEach(r => { const val = r.s || r; if(!isNaN(val.re)) { minX = Math.min(minX, val.re); maxX = Math.max(maxX, val.re); minY = Math.min(minY, val.im); maxY = Math.max(maxY, val.im); } }); };
                expandLimits(openLoopPoles); expandLimits(openLoopZeros); expandLimits(breakPoints);
                if (minX === Infinity) minX = -10; if (maxX === -Infinity) maxX = 2; if (minY === Infinity) minY = -5; if (maxY === -Infinity) maxY = 5;
                const paddingX = Math.max(1, Math.abs(maxX - minX) * 0.2); const paddingY = Math.max(1, Math.abs(maxY - minY) * 0.2);
                return { points, limits: { minX: minX - paddingX, maxX: maxX + paddingX, minY: Math.min(minY - paddingY, -5), maxY: Math.max(maxY + paddingY, 5) }, openLoopPoles, openLoopZeros, breakPoints };
            };

            self.onmessage = (e) => {
                try { const { numerator, denominator } = e.data; const result = generateRootLocusData(numerator, denominator); self.postMessage({ success: true, data: result }); } 
                catch (error) { self.postMessage({ success: false, error: error.message }); }
            };
        `;

        // --- CLIENT SIDE HELPERS ---
        const addComplex = (a, b) => ({ re: a.re + b.re, im: a.im + b.im });
        const subComplex = (a, b) => ({ re: a.re - b.re, im: a.im - b.im });
        const mulComplex = (a, b) => ({ re: a.re * b.re - a.im * b.im, im: a.re * b.im + a.im * b.re, });
        const divComplex = (a, b) => { const denom = b.re * b.re + b.im * b.im; return { re: (a.re * b.re + a.im * b.im) / denom, im: (a.im * b.re - a.re * b.im) / denom, }; };
        const absComplex = (a) => Math.sqrt(a.re * a.re + a.im * a.im);
        const evalPoly = (coeffs, s) => { let result = { re: 0, im: 0 }; for (let i = 0; i < coeffs.length; i++) { result = mulComplex(result, s); result = addComplex(result, { re: coeffs[i], im: 0 }); } return result; };
        const findRoots = (coeffs, maxIter = 50, tolerance = 1e-6) => {
            const n = coeffs.length - 1; if (n < 1) return [];
            let start = 0; while (start < coeffs.length && coeffs[start] === 0) start++;
            const activeCoeffs = coeffs.slice(start); const order = activeCoeffs.length - 1; if (order < 1) return [];
            const a0 = activeCoeffs[0]; const normalizedCoeffs = activeCoeffs.map(c => c / a0);
            let roots = []; const radius = 0.5; for (let i = 0; i < order; i++) { const angle = (2 * Math.PI * i) / order + 0.123; roots.push({ re: radius * Math.cos(angle), im: radius * Math.sin(angle) }); }
            for (let iter = 0; iter < maxIter; iter++) {
                let maxDiff = 0; const newRoots = [...roots];
                for (let i = 0; i < order; i++) {
                    const z = roots[i]; const pz = evalPoly(normalizedCoeffs, z);
                    let denominator = { re: 1, im: 0 }; for (let j = 0; j < order; j++) if (i !== j) denominator = mulComplex(denominator, subComplex(z, roots[j]));
                    const delta = divComplex(pz, denominator); newRoots[i] = subComplex(z, delta); const diff = absComplex(delta); if (diff > maxDiff) maxDiff = diff;
                }
                roots = newRoots; if (maxDiff < tolerance) break;
            }
            roots.sort((a, b) => a.re - b.re || a.im - b.im); return roots;
        };
        const getCharacteristicEq = (num, den, k) => { const maxLen = Math.max(num.length, den.length); const paddedNum = new Array(maxLen).fill(0); const paddedDen = new Array(maxLen).fill(0); for (let i = 0; i < num.length; i++) paddedNum[maxLen - 1 - i] = num[num.length - 1 - i]; for (let i = 0; i < den.length; i++) paddedDen[maxLen - 1 - i] = den[den.length - 1 - i]; const result = new Array(maxLen).fill(0); for (let i = 0; i < maxLen; i++) result[i] = paddedDen[i] + k * paddedNum[i]; return result; };
        const calcZetaFromPO = (po) => { if (po >= 100) return 0; if (po <= 0) return 1; const lnPO = Math.log(po / 100); return -lnPO / Math.sqrt(Math.PI**2 + lnPO**2); };
        const calcPOFromZeta = (z) => { if (z >= 1) return 0; if (z <= 0) return 100; return 100 * Math.exp((-Math.PI * z) / Math.sqrt(1 - z**2)); };

        const evaluateMath = (expr) => {
            try {
                if (!expr) return NaN;
                let cleanExpr = expr.trim().toLowerCase().replace(/π|pi/g, 'PI').replace(/\^/g, '**'); 
                const mathKeys = Object.getOwnPropertyNames(Math); const mathValues = mathKeys.map(k => Math[k]);
                const func = new Function(...mathKeys, `return ${cleanExpr}`); const result = func(...mathValues);
                return typeof result === 'number' && isFinite(result) ? result : NaN;
            } catch (e) { return NaN; }
        };

        const ControlPanel = ({ system, constraints, currentK, onSystemChange, onConstraintsChange, onKChange }) => {
            const [numStr, setNumStr] = React.useState(system.numerator.join(', '));
            const [denStr, setDenStr] = React.useState(system.denominator.join(', '));
            const [kStr, setKStr] = React.useState(currentK.toString());
            const [dampingStr, setDampingStr] = React.useState(constraints.minDampingRatio.toString());
            const [overshootStr, setOvershootStr] = React.useState(calcPOFromZeta(constraints.minDampingRatio).toFixed(1));
            const [settlingStr, setSettlingStr] = React.useState(constraints.maxSettlingTime.toString());
            const [freqStr, setFreqStr] = React.useState(constraints.minNaturalFreq.toString());
            const adaptiveMaxK = React.useMemo(() => { const poles = findRoots(system.denominator); if (poles.length === 0) return 100; const maxPoleMag = Math.max(...poles.map(p => absComplex(p))) || 1; let maxK = Math.max(100, Math.pow(maxPoleMag, 2) + 50); if (maxK > 10000) maxK = 10000; return Math.ceil(maxK / 10) * 10; }, [system.denominator]);
            React.useEffect(() => { if (Math.abs(evaluateMath(kStr) - currentK) > 1e-4) setKStr(currentK.toString()); }, [currentK]);
            React.useEffect(() => { if (Math.abs(evaluateMath(dampingStr) - constraints.minDampingRatio) > 1e-4) { setDampingStr(constraints.minDampingRatio.toString()); setOvershootStr(calcPOFromZeta(constraints.minDampingRatio).toFixed(1)); } }, [constraints.minDampingRatio]);

            const handleNumBlur = () => { const arr = numStr.split(',').map(s => evaluateMath(s.trim())).filter(n => !isNaN(n)); if (arr.length > 0) onSystemChange({ ...system, numerator: arr }); else setNumStr(system.numerator.join(', ')); };
            const handleDenBlur = () => { const arr = denStr.split(',').map(s => evaluateMath(s.trim())).filter(n => !isNaN(n)); if (arr.length > 0) onSystemChange({ ...system, denominator: arr }); else setDenStr(system.denominator.join(', ')); };
            const handleKBlur = () => { const val = evaluateMath(kStr); if(!isNaN(val) && val >= 0) onKChange(val); else setKStr(currentK.toString()); };
            const handleConstraintBlur = (field, valueStr, setter, min, max) => { const val = evaluateMath(valueStr); if (!isNaN(val)) { const clamped = Math.max(min, Math.min(max, val)); onConstraintsChange({ ...constraints, [field]: clamped }); if (clamped !== val) setter(clamped.toString()); } else setter(constraints[field].toString()); };
            const handleOvershootBlur = () => { const po = evaluateMath(overshootStr); if (!isNaN(po)) { const clampedPO = Math.max(0, Math.min(100, po)); const newZeta = calcZetaFromPO(clampedPO); onConstraintsChange({ ...constraints, minDampingRatio: newZeta }); setOvershootStr(clampedPO.toString()); } else setOvershootStr(calcPOFromZeta(constraints.minDampingRatio).toFixed(1)); };
            const currentPoles = React.useMemo(() => { const poly = getCharacteristicEq(system.numerator, system.denominator, currentK); return findRoots(poly); }, [system, currentK]);
            const validation = React.useMemo(() => { let stable = true, meetsZeta = true, meetsTs = true, meetsWn = true; const sigmaLimit = -4 / constraints.maxSettlingTime; currentPoles.forEach(p => { if (p.re >= 0) stable = false; const wn = absComplex(p); const zeta = wn === 0 ? 1 : -p.re / wn; if (p.re > 1e-6) stable = false; if (constraints.enableDamping && zeta < constraints.minDampingRatio - 1e-4) meetsZeta = false; if (constraints.enableSettling && p.re > sigmaLimit + 1e-4) meetsTs = false; if (constraints.enableNatFreq && wn < constraints.minNaturalFreq - 1e-4) meetsWn = false; }); return { stable, meetsZeta, meetsTs, meetsWn }; }, [currentPoles, constraints]);
            const allPassed = validation.stable && (validation.meetsZeta || !constraints.enableDamping) && (validation.meetsTs || !constraints.enableSettling) && (validation.meetsWn || !constraints.enableNatFreq);

            return (
                <div className="w-full bg-white lg:rounded-xl shadow-sm border border-gray-200 flex flex-col h-full text-gray-800">
                    <div className="flex-1 overflow-y-auto p-4 md:p-6 space-y-6 custom-scrollbar">
                        <div className="space-y-4">
                            <div className="flex items-center gap-2 mb-2"><i className="fas fa-microchip text-indigo-500"></i><h2 className="text-lg font-bold text-gray-800">System Model</h2></div>
                            <div className="space-y-3">
                                <div><label className="text-xs uppercase tracking-wider font-semibold text-gray-500 mb-1 block">Numerator N(s)</label><input type="text" value={numStr} onChange={(e) => setNumStr(e.target.value)} onBlur={handleNumBlur} className="w-full bg-white border border-gray-300 rounded px-3 py-2 text-sm font-mono focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 focus:outline-none transition-colors" placeholder="e.g. 1, 2" /></div>
                                <div><label className="text-xs uppercase tracking-wider font-semibold text-gray-500 mb-1 block">Denominator D(s)</label><input type="text" value={denStr} onChange={(e) => setDenStr(e.target.value)} onBlur={handleDenBlur} className="w-full bg-white border border-gray-300 rounded px-3 py-2 text-sm font-mono focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 focus:outline-none transition-colors" placeholder="e.g. 1, 6, 8, 0" /></div>
                            </div>
                        </div>
                        <hr className="border-gray-100" />
                        <div className="space-y-4">
                            <div className="flex items-center gap-2 mb-2"><i className="fas fa-ruler-combined text-green-500"></i><h2 className="text-lg font-bold text-gray-800">Design Specs</h2></div>
                            <div className={`bg-gray-50 p-3 rounded-lg border transition-colors ${constraints.enableDamping ? 'border-gray-200' : 'border-transparent opacity-60'}`}>
                                <div className="flex justify-between items-center mb-1"><div className="flex items-center gap-2"><input type="checkbox" checked={constraints.enableDamping} onChange={(e) => onConstraintsChange({...constraints, enableDamping: e.target.checked})} className="w-4 h-4 rounded border-gray-300 text-green-600 focus:ring-green-500 cursor-pointer" /><label className="text-xs font-semibold text-gray-600">Transient Response</label></div>{constraints.enableDamping && (<span className={`text-[10px] font-mono px-1.5 py-0.5 rounded font-bold ${validation.meetsZeta ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>{validation.meetsZeta ? 'PASS' : 'FAIL'}</span>)}</div>
                                <div className="flex gap-2 items-center mb-2"><span className="text-[10px] font-bold text-gray-400 w-16">Min ζ</span><input type="range" min="0" max="0.99" step="0.01" value={constraints.minDampingRatio} disabled={!constraints.enableDamping} onChange={(e) => { const val = parseFloat(e.target.value); onConstraintsChange({...constraints, minDampingRatio: val}); setDampingStr(val.toString()); setOvershootStr(calcPOFromZeta(val).toFixed(1)); }} className={`flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-green-600 ${!constraints.enableDamping && 'grayscale cursor-not-allowed'}`} /><input type="text" value={dampingStr} onChange={(e) => setDampingStr(e.target.value)} disabled={!constraints.enableDamping} onBlur={() => handleConstraintBlur('minDampingRatio', dampingStr, setDampingStr, 0, 0.999)} className={`w-14 bg-white border border-gray-300 rounded px-2 py-1 text-xs text-center font-mono focus:border-green-500 focus:outline-none`} /></div>
                                <div className="flex gap-2 items-center"><span className="text-[10px] font-bold text-gray-400 w-16">Max %OS</span><div className="flex-1"></div><input type="text" value={overshootStr} onChange={(e) => setOvershootStr(e.target.value)} disabled={!constraints.enableDamping} onBlur={handleOvershootBlur} className={`w-14 bg-white border border-gray-300 rounded px-2 py-1 text-xs text-center font-mono focus:border-green-500 focus:outline-none`} /></div>
                            </div>
                            <div className={`bg-gray-50 p-3 rounded-lg border transition-colors ${constraints.enableSettling ? 'border-gray-200' : 'border-transparent opacity-60'}`}>
                                <div className="flex justify-between items-center mb-1"><div className="flex items-center gap-2"><input type="checkbox" checked={constraints.enableSettling} onChange={(e) => onConstraintsChange({...constraints, enableSettling: e.target.checked})} className="w-4 h-4 rounded border-gray-300 text-green-600 focus:ring-green-500 cursor-pointer" /><label className="text-xs font-semibold text-gray-600">Max Settling (<span className="font-serif italic">T<sub>s</sub></span>)</label></div>{constraints.enableSettling && (<span className={`text-[10px] font-mono px-1.5 py-0.5 rounded font-bold ${validation.meetsTs ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>{validation.meetsTs ? 'PASS' : 'FAIL'}</span>)}</div>
                                <div className="flex gap-2 items-center"><input type="text" value={settlingStr} onChange={(e) => setSettlingStr(e.target.value)} disabled={!constraints.enableSettling} onBlur={() => handleConstraintBlur('maxSettlingTime', settlingStr, setSettlingStr, 0.1, 1000)} className={`w-full bg-white border border-gray-300 rounded px-2 py-1.5 text-sm font-mono focus:border-green-500 focus:outline-none text-center`} /><span className="text-xs text-gray-500 whitespace-nowrap">sec</span></div>
                            </div>
                            <div className={`bg-gray-50 p-3 rounded-lg border transition-colors ${constraints.enableNatFreq ? 'border-gray-200' : 'border-transparent opacity-60'}`}>
                                <div className="flex justify-between items-center mb-1"><div className="flex items-center gap-2"><input type="checkbox" checked={constraints.enableNatFreq} onChange={(e) => onConstraintsChange({...constraints, enableNatFreq: e.target.checked})} className="w-4 h-4 rounded border-gray-300 text-green-600 focus:ring-green-500 cursor-pointer" /><label className="text-xs font-semibold text-gray-600">Min Nat. Freq. (<span className="font-serif italic">ω<sub>n</sub></span>)</label></div>{constraints.enableNatFreq && (<span className={`text-[10px] font-mono px-1.5 py-0.5 rounded font-bold ${validation.meetsWn ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>{validation.meetsWn ? 'PASS' : 'FAIL'}</span>)}</div>
                                <div className="flex gap-2 items-center"><input type="text" value={freqStr} onChange={(e) => setFreqStr(e.target.value)} disabled={!constraints.enableNatFreq} onBlur={() => handleConstraintBlur('minNaturalFreq', freqStr, setFreqStr, 0, 1000)} className={`w-full bg-white border border-gray-300 rounded px-2 py-1.5 text-sm font-mono focus:border-green-500 focus:outline-none text-center`} /><span className="text-xs text-gray-500 whitespace-nowrap">rad/s</span></div>
                            </div>
                        </div>
                        <hr className="border-gray-100" />
                        <div className="space-y-4">
                            <div className="flex items-center justify-between mb-2"><div className="flex items-center gap-2"><i className="fas fa-sliders-h text-indigo-500"></i><h2 className="text-lg font-bold text-gray-800">Gain Tuning</h2></div><div className={`px-2 py-1 rounded text-[10px] font-bold tracking-wider ${allPassed ? 'bg-green-100 text-green-700' : 'bg-gray-200 text-gray-500'}`}>{allPassed ? 'DESIGN MET' : 'TUNING'}</div></div>
                            <div className="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                                <label className="flex justify-between text-sm font-semibold text-indigo-600 mb-2"><span>Controller Gain (K)</span><span className="text-xs text-gray-400 font-normal">Max: {adaptiveMaxK}</span></label>
                                <div className="flex gap-3 mb-3"><input type="range" min="0" max={adaptiveMaxK} step={adaptiveMaxK / 1000} value={currentK} onChange={(e) => { onKChange(parseFloat(e.target.value)); setKStr(e.target.value); }} className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600 self-center" /><input type="text" value={kStr} onChange={(e) => setKStr(e.target.value)} onBlur={handleKBlur} className="w-16 bg-white border border-gray-300 rounded px-2 py-1 text-sm font-mono text-center text-indigo-700 font-bold focus:outline-none focus:border-indigo-500" /></div>
                                <div className="space-y-1"><p className="text-xs text-gray-400 border-b border-gray-100 pb-1 mb-1">Closed-Loop Poles:</p>{currentPoles.map((p, i) => (<div key={i} className={`text-xs font-mono flex justify-between ${p.re > 0 ? 'text-red-500 font-bold' : 'text-gray-600'}`}><span>s<sub>{i+1}</sub> = {p.re.toFixed(3)} {p.im >= 0 ? '+' : ''}{p.im.toFixed(3)}j</span><span className="text-gray-400">ζ={(p.im === 0 && p.re < 0) ? '1.0' : (p.re === 0 && p.im !== 0) ? '0.0' : (-p.re / absComplex(p)).toFixed(2)}</span></div>))}{!validation.stable && <div className="text-red-500 text-xs font-bold mt-2 text-center animate-pulse">SYSTEM UNSTABLE</div>}</div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const RootLocusPlot = ({ system, constraints, currentK }) => {
            const [hoverInfo, setHoverInfo] = React.useState(null);
            const [transform, setTransform] = React.useState({ k: 1, x: 0, y: 0 });
            const [isDragging, setIsDragging] = React.useState(false);
            const containerRef = React.useRef(null);
            const [dimensions, setDimensions] = React.useState({ width: 800, height: 600 });
            const [plotData, setPlotData] = React.useState(null);
            const [isCalculating, setIsCalculating] = React.useState(false);
            const workerRef = React.useRef(null);
            
            // Refs for interaction
            const dragStartRef = React.useRef(null);
            const transformStartRef = React.useRef(null);
            const pinchRef = React.useRef(null); // Stores { dist, k, x, y, midX, midY } for pinch

            React.useEffect(() => {
                const blob = new Blob([workerScript], { type: 'application/javascript' });
                const worker = new Worker(URL.createObjectURL(blob));
                workerRef.current = worker;
                worker.onmessage = (e) => { if (e.data.success) { setPlotData(e.data.data); setIsCalculating(false); } };
                return () => worker.terminate();
            }, []);

            React.useEffect(() => {
                if (workerRef.current) { setIsCalculating(true); const timer = setTimeout(() => { workerRef.current.postMessage({ numerator: system.numerator, denominator: system.denominator }); }, 10); return () => clearTimeout(timer); }
            }, [system.numerator, system.denominator]);

            React.useEffect(() => {
                const updateSize = () => { if (containerRef.current) setDimensions({ width: containerRef.current.clientWidth, height: containerRef.current.clientHeight }); };
                const resizeObserver = new ResizeObserver(updateSize); if (containerRef.current) { resizeObserver.observe(containerRef.current); updateSize(); } return () => resizeObserver.disconnect();
            }, []);

            React.useEffect(() => { if (plotData) setTransform({ k: 1, x: 0, y: 0 }); }, [plotData?.limits.minX, plotData?.limits.maxX]);

            const currentPoles = React.useMemo(() => { const poly = getCharacteristicEq(system.numerator, system.denominator, currentK); return findRoots(poly); }, [system.numerator, system.denominator, currentK]);
            const { width, height } = dimensions;
            
            const margin = 50; 
            const limits = plotData?.limits || { minX: -10, maxX: 2, minY: -5, maxY: 5 };
            const dataWidth = limits.maxX - limits.minX; const dataHeight = limits.maxY - limits.minY;
            const availableWidth = width - 2 * margin; const availableHeight = height - 2 * margin;
            const scaleFactor = Math.min(availableWidth / Math.max(0.001, dataWidth), availableHeight / Math.max(0.001, dataHeight));
            const centerX = width / 2; const centerY = height / 2; const dataCenterX = (limits.minX + limits.maxX) / 2; const dataCenterY = (limits.minY + limits.maxY) / 2;
            const baseScaleX = (val) => centerX + (val - dataCenterX) * scaleFactor;
            const baseScaleY = (val) => centerY - (val - dataCenterY) * scaleFactor; 
            const scaleX = (val) => baseScaleX(val) * transform.k + transform.x;
            const scaleY = (val) => baseScaleY(val) * transform.k + transform.y;
            const invertScaleX = (px) => dataCenterX + ((px - transform.x) / transform.k - centerX) / scaleFactor;
            const invertScaleY = (py) => dataCenterY - ((py - transform.y) / transform.k - centerY) / scaleFactor;

            const getTicks = (min, max) => {
                const span = max - min; if (span <= 1e-9) return [min];
                const stepPower = Math.floor(Math.log10(span / 6)); let step = Math.pow(10, stepPower);
                if (span / step > 12) step *= 2; if (span / step > 12) step *= 2.5; 
                const start = Math.ceil(min / step) * step; const ticks = [];
                for (let t = start; t <= max + step/100; t += step) ticks.push(t);
                return ticks;
            };
            const xTicks = getTicks(invertScaleX(0), invertScaleX(width));
            const yTicks = getTicks(invertScaleY(height), invertScaleY(0));

            // --- INTERACTION LOGIC (WHEEL & TOUCH) ---
            const handleWheel = (e) => {
                const scaleFactor = 1.1; const direction = e.deltaY < 0 ? 1 : -1; const factor = direction > 0 ? scaleFactor : 1 / scaleFactor;
                const newK = Math.max(0.1, Math.min(50, transform.k * factor));
                const svgRect = e.currentTarget.getBoundingClientRect();
                const mouseX = e.clientX - svgRect.left; const mouseY = e.clientY - svgRect.top;
                const newX = mouseX - (mouseX - transform.x) * (newK / transform.k);
                const newY = mouseY - (mouseY - transform.y) * (newK / transform.k);
                setTransform({ k: newK, x: newX, y: newY });
            };

            const handleMouseDown = (e) => {
                if (e.button !== 0) return; setIsDragging(true);
                dragStartRef.current = { x: e.clientX, y: e.clientY }; transformStartRef.current = { ...transform };
            };
            const handleMouseMove = (e) => {
                if (!isDragging || !dragStartRef.current || !transformStartRef.current) return;
                const dx = e.clientX - dragStartRef.current.x; const dy = e.clientY - dragStartRef.current.y;
                setTransform({ ...transform, x: transformStartRef.current.x + dx, y: transformStartRef.current.y + dy });
            };
            const handleMouseUp = () => { setIsDragging(false); dragStartRef.current = null; transformStartRef.current = null; pinchRef.current = null; };

            // --- MULTI-TOUCH LOGIC ---
            const handleTouchStart = (e) => {
                if (e.touches.length === 1) {
                    // Pan Start
                    const touch = e.touches[0]; setIsDragging(true);
                    dragStartRef.current = { x: touch.clientX, y: touch.clientY };
                    transformStartRef.current = { ...transform };
                } else if (e.touches.length === 2) {
                    // Pinch Start
                    setIsDragging(false); // Disable pan
                    const t1 = e.touches[0]; const t2 = e.touches[1];
                    const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                    const midX = (t1.clientX + t2.clientX) / 2;
                    const midY = (t1.clientY + t2.clientY) / 2;
                    // Get offset relative to SVG
                    const svgRect = e.currentTarget.getBoundingClientRect();
                    const relMidX = midX - svgRect.left; 
                    const relMidY = midY - svgRect.top;

                    pinchRef.current = { 
                        startDist: dist, 
                        startK: transform.k, 
                        startX: transform.x, 
                        startY: transform.y,
                        midX: relMidX,
                        midY: relMidY
                    };
                }
            };

            const handleTouchMove = (e) => {
                if (e.touches.length === 1 && isDragging && dragStartRef.current && transformStartRef.current) {
                    // Pan Move
                    const touch = e.touches[0];
                    const dx = touch.clientX - dragStartRef.current.x; const dy = touch.clientY - dragStartRef.current.y;
                    setTransform({ ...transform, x: transformStartRef.current.x + dx, y: transformStartRef.current.y + dy });
                } else if (e.touches.length === 2 && pinchRef.current) {
                    // Pinch Move
                    const t1 = e.touches[0]; const t2 = e.touches[1];
                    const currDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                    
                    if (pinchRef.current.startDist > 0) {
                        const scale = currDist / pinchRef.current.startDist;
                        const newK = Math.max(0.1, Math.min(50, pinchRef.current.startK * scale));
                        
                        // Zoom towards midpoint
                        const midX = pinchRef.current.midX; 
                        const midY = pinchRef.current.midY;
                        
                        const newX = midX - (midX - pinchRef.current.startX) * (newK / pinchRef.current.startK);
                        const newY = midY - (midY - pinchRef.current.startY) * (newK / pinchRef.current.startK);

                        setTransform({ k: newK, x: newX, y: newY });
                    }
                    e.preventDefault(); // Prevent browser zoom
                }
            };

            const handleReset = () => setTransform({ k: 1, x: 0, y: 0 });
            const handleZoomIn = () => setTransform(p => ({ ...p, k: p.k * 1.2, x: p.x - (width/2 - p.x) * 0.2, y: p.y - (height/2 - p.y) * 0.2 }));
            const handleZoomOut = () => setTransform(p => ({ ...p, k: p.k / 1.2, x: p.x - (width/2 - p.x) * (1/1.2 - 1), y: p.y - (height/2 - p.y) * (1/1.2 - 1) }));

            const zeta = constraints.minDampingRatio; const sigmaMax = -4 / constraints.maxSettlingTime; const wn = constraints.minNaturalFreq; const zetaAngle = Math.acos(zeta); const zetaSlope = Math.tan(zetaAngle);
            const renderLocus = () => { if (!plotData) return null; return plotData.points.flatMap((pt, i) => pt.roots.map((root, j) => { const x = scaleX(root.re); const y = scaleY(root.im); if (x < -100 || x > width + 100 || y < -100 || y > height + 100) return null; return (<circle key={`${i}-${j}`} cx={x} cy={y} r={3 * Math.sqrt(transform.k < 0.5 ? 0.5 : transform.k > 2 ? 2 : transform.k)} fill="#3b82f6" className="hover:fill-blue-300 transition-colors" onMouseEnter={() => setHoverInfo({ k: pt.k, s: root, x, y })} onMouseLeave={() => setHoverInfo(null)} />); })); };
            const huge = 10000; const conePath = `M ${scaleX(0)} ${scaleY(0)} L ${scaleX(-huge)} ${scaleY(-huge * zetaSlope)} L ${scaleX(-huge)} ${scaleY(huge * zetaSlope)} Z`;
            const invalidTsX = scaleX(sigmaMax); const wnRadiusX = Math.abs(scaleX(wn) - scaleX(0)); 

            return (
                <div ref={containerRef} className="relative w-full h-full flex flex-col items-center justify-center bg-white rounded-xl overflow-hidden shadow-sm border border-gray-200 select-none group">
                    {(isCalculating || !plotData) && (<div className="absolute inset-0 z-50 bg-white/80 backdrop-blur-sm flex flex-col items-center justify-center transition-opacity"><div className="w-12 h-12 border-4 border-gray-200 border-t-indigo-500 rounded-full animate-spin mb-4"></div><span className="text-indigo-500 font-mono font-bold animate-pulse">Calculating Locus...</span></div>)}
                    <div className="absolute top-2 left-2 z-10 pointer-events-none select-none"><div className="bg-white/90 p-2 rounded-lg backdrop-blur border border-gray-200 shadow-lg"><h3 className="text-gray-700 font-bold text-xs mb-1 hidden sm:block"><i className="fas fa-map text-indigo-500 mr-2"></i>S-Plane Map</h3><div className="grid grid-cols-2 gap-x-3 gap-y-1 text-[9px] sm:text-[10px] text-gray-500"><div className="flex items-center gap-1"><div className="w-2 h-2 bg-green-500/30 border border-green-500"></div> Feasible</div><div className="flex items-center gap-1"><div className="w-2 h-2 bg-red-500/20 border border-red-500/50"></div> Violation</div><div className="flex items-center gap-1"><div className="w-2 h-2 rounded-full bg-blue-500"></div> Locus</div><div className="flex items-center gap-1"><div className="w-2 h-2 bg-fuchsia-500 border border-white"></div> Current</div><div className="flex items-center gap-1 col-span-2"><div className="w-2 h-2 bg-orange-400 rotate-45"></div> Breakaway/in</div></div></div></div>
                    <div className="absolute top-4 right-4 z-20 flex flex-col gap-2"><button onClick={handleReset} className="w-8 h-8 bg-white hover:bg-gray-100 text-gray-700 border border-gray-300 rounded shadow flex items-center justify-center active:bg-gray-200 transition-colors" title="Reset View"><i className="fas fa-compress-arrows-alt text-xs"></i></button><button onClick={handleZoomIn} className="w-8 h-8 bg-white hover:bg-gray-100 text-gray-700 border border-gray-300 rounded shadow flex items-center justify-center active:bg-gray-200 transition-colors" title="Zoom In"><i className="fas fa-plus text-xs"></i></button><button onClick={handleZoomOut} className="w-8 h-8 bg-white hover:bg-gray-100 text-gray-700 border border-gray-300 rounded shadow flex items-center justify-center active:bg-gray-200 transition-colors" title="Zoom Out"><i className="fas fa-minus text-xs"></i></button></div>
                    {hoverInfo && (<div className="absolute z-50 bg-white/95 text-gray-700 text-xs p-2 rounded-lg shadow-xl border border-indigo-200 pointer-events-none whitespace-nowrap backdrop-blur" style={{ left: Math.min(width - 150, Math.max(0, hoverInfo.x + 10)), top: Math.min(height - 100, hoverInfo.y - 10) }}><div className="font-bold text-indigo-600 mb-1 border-b border-gray-200 pb-1">{hoverInfo.isBreakaway ? "Break Point" : "Locus Point"}</div>{hoverInfo.isBreakaway ? (<p><span className="text-gray-400">s:</span> {hoverInfo.s.re.toFixed(3)}</p>) : (<><p><span className="text-gray-400">K:</span> {hoverInfo.k.toFixed(3)}</p><p><span className="text-gray-400">s:</span> {hoverInfo.s.re.toFixed(2)} {hoverInfo.s.im >= 0 ? '+' : ''}{hoverInfo.s.im.toFixed(2)}j</p><p><span className="text-gray-400">ζ:</span> {(-Math.cos(Math.atan2(hoverInfo.s.im, hoverInfo.s.re))).toFixed(3)}</p></>)}</div>)}
                    <svg 
                        width="100%" height="100%" style={{ touchAction: 'none' }}
                        className={`w-full h-full ${isDragging ? 'cursor-grabbing' : 'cursor-grab'} transition-opacity duration-300 ${isCalculating ? 'opacity-30' : 'opacity-100'}`}
                        viewBox={`0 0 ${width || 800} ${height || 600}`}
                        onWheel={handleWheel}
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseUp}
                        onTouchStart={handleTouchStart}
                        onTouchMove={handleTouchMove}
                        onTouchEnd={handleMouseUp}
                    >
                        <rect width="100%" height="100%" fill="#ffffff" />
                        <g className="grid-lines" stroke="#f1f5f9" strokeWidth="1">{xTicks.map(t => { const x = scaleX(t); return <line key={`xgrid-${t}`} x1={x} y1={0} x2={x} y2={height} />; })}{yTicks.map(t => { const y = scaleY(t); return <line key={`ygrid-${t}`} x1={0} y1={y} x2={width} y2={y} />; })}</g>
                        {constraints.enableDamping ? (<path d={conePath} fill="#22c55e" fillOpacity="0.1" />) : (<rect width="100%" height="100%" fill="#22c55e" fillOpacity="0.03" />)}
                        {constraints.enableSettling && (<><rect x={invalidTsX} y={-10000} width={20000} height={20000} fill="#ef4444" fillOpacity="0.08" /><line x1={invalidTsX} y1={-1000} x2={invalidTsX} y2={height + 1000} stroke="#ef4444" strokeWidth="1" strokeDasharray="4,4" opacity="0.4" /></>)}
                        {constraints.enableNatFreq && (<circle cx={scaleX(0)} cy={scaleY(0)} r={wnRadiusX} fill="#ef4444" fillOpacity="0.08" stroke="#ef4444" strokeWidth="1" strokeDasharray="4,4" />)}
                        <line x1={scaleX(-10000)} y1={scaleY(0)} x2={scaleX(10000)} y2={scaleY(0)} stroke="#94a3b8" strokeWidth="2" />
                        <line x1={scaleX(0)} y1={scaleY(-10000)} x2={scaleX(0)} y2={scaleY(10000)} stroke="#94a3b8" strokeWidth="2" />
                        <g className="ticks" fontSize="10" fill="#64748b" textAnchor="middle">
                            {xTicks.map(t => { const x = scaleX(t); const y = scaleY(0); if (Math.abs(t) < 1e-9) return null; return (<g key={`xtick-${t}`}><line x1={x} y1={y} x2={x} y2={y+5} stroke="#94a3b8" strokeWidth="1"/><text x={x} y={y+15}>{parseFloat(t.toPrecision(4))}</text></g>); })}
                            {yTicks.map(t => { const y = scaleY(t); const x = scaleX(0); if (Math.abs(t) < 1e-9) return null; return (<g key={`ytick-${t}`}><line x1={x} y1={y} x2={x-5} y2={y} stroke="#94a3b8" strokeWidth="1"/><text x={x-8} y={y+3} textAnchor="end">{parseFloat(t.toPrecision(4))}</text></g>); })}
                            <text x={scaleX(0)-5} y={scaleY(0)+12} fontWeight="bold">0</text>
                        </g>
                        <g>{renderLocus()}</g>
                        {currentPoles.map((p, i) => { const x = scaleX(p.re); const y = scaleY(p.im); if(x < -50 || x > width + 50 || y < -50 || y > height + 50) return null; return (<g key={`cl-pole-${i}`} className="drop-shadow-sm pointer-events-none"><rect x={x-5} y={y-5} width={10} height={10} fill="#d946ef" stroke="white" strokeWidth="1.5"/><text x={x+8} y={y-8} fill="#c026d3" fontSize="10" fontWeight="bold">s{i+1}</text></g>); })}
                        {plotData && plotData.breakPoints && plotData.breakPoints.map((bp, i) => { const x = scaleX(bp.s.re); const y = scaleY(bp.s.im); if(x < -50 || x > width + 50 || y < -50 || y > height + 50) return null; return (<g key={`break-${i}`} onMouseEnter={() => setHoverInfo({ k: bp.k, s: bp.s, x, y, isBreakaway: true })} onMouseLeave={() => setHoverInfo(null)}><rect x={x-4} y={y-4} width={8} height={8} fill="#fb923c" transform={`rotate(45 ${x} ${y})`} stroke="white" strokeWidth="1" /></g>) })}
                        {plotData && plotData.openLoopPoles.map((p, i) => { const x = scaleX(p.re); const y = scaleY(p.im); const size = 6; if(x < -50 || x > width + 50 || y < -50 || y > height + 50) return null; return (<g key={`ol-pole-${i}`}><line x1={x-size} y1={y-size} x2={x+size} y2={y+size} stroke="#f87171" strokeWidth="2" /><line x1={x+size} y1={y-size} x2={x-size} y2={y+size} stroke="#f87171" strokeWidth="2" /></g>); })}
                        {plotData && plotData.openLoopZeros.map((z, i) => { const x = scaleX(z.re); const y = scaleY(z.im); if(x < -50 || x > width + 50 || y < -50 || y > height + 50) return null; return (<circle key={`ol-zero-${i}`} cx={x} cy={y} r={5} stroke="#f87171" strokeWidth="2" fill="none" />); })}
                    </svg>
                    <div className="absolute bottom-2 right-4 font-mono text-gray-500 text-xs tracking-wider bg-white/80 px-2 rounded">Real Axis (σ)</div>
                    <div className="absolute top-4 left-4 font-mono text-gray-500 text-xs tracking-wider bg-white/80 px-2 rounded">Imaginary Axis (jω)</div>
                </div>
            );
        };

        const App = () => {
            const [system, setSystem] = React.useState({ numerator: [1], denominator: [1, 6, 8, 0] });
            const [constraints, setConstraints] = React.useState({ minDampingRatio: 0.5, enableDamping: true, maxSettlingTime: 4.0, enableSettling: true, minNaturalFreq: 1.0, enableNatFreq: true });
            const [currentK, setCurrentK] = React.useState(1.0);
            React.useEffect(() => { const loader = document.getElementById('loader'); if (loader) { loader.style.opacity = '0'; setTimeout(() => loader.remove(), 500); } }, []);
            return (
                <div className="flex flex-col h-screen bg-gray-50 text-gray-800 font-sans overflow-hidden selection:bg-indigo-100">
                    <header className="flex-none h-14 border-b border-gray-200 bg-white/80 backdrop-blur-md flex items-center px-4 md:px-6 shadow-sm z-40 justify-between"><div className="flex items-center gap-3"><div className="w-8 h-8 bg-indigo-600 rounded-lg flex items-center justify-center text-white font-bold text-lg shadow-md"><i className="fas fa-wave-square text-sm"></i></div><h1 className="text-lg font-bold tracking-tight text-gray-800">LTI Control <span className="text-indigo-600 font-light">Designer</span></h1></div><div className="text-xs text-gray-500 font-mono hidden md:block">Local Math Engine</div></header>
                    <div className="flex-1 flex flex-col lg:flex-row overflow-hidden relative">
                        <div className="order-1 lg:order-2 h-[50vh] lg:h-full lg:flex-1 p-2 md:p-6 overflow-hidden flex flex-col gap-4 relative bg-gray-50"><div className="flex-1 w-full h-full min-h-0 shadow-lg rounded-xl overflow-hidden border border-gray-200 relative"><RootLocusPlot system={system} constraints={constraints} currentK={currentK} /></div></div>
                        <div className="order-2 lg:order-1 h-[50vh] lg:h-full w-full lg:w-96 flex-none z-30 shadow-xl bg-white lg:border-r border-t lg:border-t-0 border-gray-200"><ControlPanel system={system} constraints={constraints} currentK={currentK} onSystemChange={setSystem} onConstraintsChange={setConstraints} onKChange={setCurrentK} /></div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
